import{_ as e,r as t,o as p,c as o,a as n,b as s,d as c,e as l}from"./app-BSbwKVVv.js";const i={},r=n("h1",{id:"raii和智能指针",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#raii和智能指针"},[n("span",null,"RAII和智能指针")])],-1),u=n("blockquote",null,[n("p",null,"引: c++不像Java或是Python拥有自动的回收处理机制")],-1),d=n("p",null,"这篇来讲讲cpp当中的智能指针，正如引子讲的那样，c或c类语言基本都没一种自动的回收机制，这也是出现什么野指针、空悬指针、重复释放、内存泄漏等等tricky bug的原因。",-1),k=n("p",null,"在c当中确确实实就只能通过很小心翼翼的设计才能避免这个问题，但是在c++当中引入的RAII可以一定程度的解决这个问题。",-1),m={href:"https://learn.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170",target:"_blank",rel:"noopener noreferrer"},h=l(`<h2 id="对象生存期" tabindex="-1"><a class="header-anchor" href="#对象生存期"><span>对象生存期</span></a></h2><p>那么什么是一个对象的生存期呢？举两个例子你就懂了</p><ol><li>在这个例子当中，i在for loop结束之后仍然存在<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>在这个例子当中，i在for循环结束后便不复存在<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>一个变量、函数、类的生存期从它被调用<strong>构造函数</strong>就开始了，而生存期到期的时候，应该调用<strong>析构函数</strong>来释放它所占用的资源。</p><h2 id="raii" tabindex="-1"><a class="header-anchor" href="#raii"><span>RAII</span></a></h2><p><strong>资源管理 RAII</strong>全称<strong>Resource Acquisition Is Initialiaztion</strong>。其目的就是为了不用new delete来手动对资源进行创建和释放，而自动在对象离开生存期或者说作用域的时候，自动调用析构函数来释放资源。</p><p>在使用裸指针时(类似C当中的使用<code>int *p = &amp;i;</code>)，我们常常需要对其进行显式的<code>delete</code>来释放其资源。</p><p>而智能指针就是C++当中对RAII的实现方案之一，它不需要我们进行显式的资源释放，也就是<code>delete</code>。也就是说，在对于使用智能指针的对象，在其生存期完的时候，会自动调用其<strong>析构函数</strong>，释放其资源。</p><p>下面来介绍智能指针的三巨头</p><ol><li><code>unique_ptr</code>：独享资源所有权</li><li><code>shared_ptr</code>：共享资源所有权</li><li><code>weak_ptr</code>：共享资源的观察者，配合<code>shared_ptr</code>使用</li></ol><h2 id="智能指针" tabindex="-1"><a class="header-anchor" href="#智能指针"><span>智能指针</span></a></h2><p>智能指针被定义在这个库当中<code>#include &lt;memory&gt;</code>。</p><h3 id="unique-ptr" tabindex="-1"><a class="header-anchor" href="#unique-ptr"><span>unique_ptr</span></a></h3><blockquote><p>标准: c++-11</p></blockquote><p>在聊<code>unique_ptr</code>之前，我们先了解一下被它所上位替代的淘汰者<code>auto_ptr</code>。也就是说C++11标准是前者的“生日”，也是后者的“忌日”。</p><ul><li><p>直接说结论：<code>unique_ptr</code>相较于<code>auto_ptr</code></p><ol><li>禁用左值引用的拷贝构造</li><li>禁用赋值重载函数</li></ol></li><li><p>这样的改变加强了智能指针的安全性，在对于被拷贝的原指针有一个恰当的处理，不至于出现指针空悬的情况。</p></li><li><p><code>unique_ptr</code>是专属所有权，所以<code>unique_ptr</code>管理的内存，<strong>只能被一个对象持有，不支持复制和赋值</strong>。</p></li><li><p>移动语义：<code>unique_ptr</code>禁止了拷贝语义，但有时我们也需要能够转移所有权，于是提供了移动语义，即可以使用<code>std::move()</code>进行控制所有权的转移。</p></li></ul><p>来看一组实例</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p1<span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">}</span><span class="token punctuation">;</span>      <span class="token comment">// 正确的</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>          <span class="token comment">// 错误，禁用拷贝构造</span>
unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p2<span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 禁用左值引用拷贝构造，关我右值move迁移何事</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><blockquote><p>C++-14当中添加了动态构建<code>make_unique()</code></p></blockquote><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
threads_<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 报错，就理解为unique_ptr在转移的时候，必须要用右值</span>
threads_<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 正确</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><blockquote><p>加锁：<code>std::unique_lock</code></p></blockquote><ul><li><code>unique_lock</code>也是RAII的一部分。lock 对象本身不是锁，而是智能锁管理对象，它的构造函数和析构函数用来管理与其关联的 mutex 对象的锁定和解锁状态。当 lock 构造时，它自动获取与之关联的 mutex 的锁定权；当 lock 超出作用域并被销毁时，它自动释放这个 mutex。这就确保了即使在有异常抛出的情况下，锁也能被正确释放，避免死锁。</li></ul><p>以下是构建<code>unique_lock</code>的过程，我们不再需要显示的<code>lock</code>和<code>unlock</code>锁。<code>std::unique_lock</code> 在析构时自动释放锁。但它还允许你在作用域内显式地释放和重新获取锁。这增加了灵活性，例如用于条件变量等。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token comment">// 创建一个mutex互斥量类型的变量mtx</span>
std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>
<span class="token comment">// 对mutex类型的mtx进行加锁，unique_lock类型的lck只是一个管理锁的东西</span>
std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lck</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Q: 为什么不直接用<code>std::mutex</code>里面内置的<code>lock</code>和<code>unlock</code>来进行锁的acquire和release？<br> A: 有可能死锁，不符合RAII规范。具体表现是，如果在<code>acquire lock</code>之后，但在<code>release lock</code>之前，也就是被锁的主体部分，程序出现了异常，那么这个资源就会一直被锁住而不会被释放。</p><h3 id="shared-ptr和weak-ptr" tabindex="-1"><a class="header-anchor" href="#shared-ptr和weak-ptr"><span>shared_ptr和weak_ptr</span></a></h3><p>shared_ptr:</p><ol><li><p><code>shared_ptr</code>通过一个引用计数共享一个对象(需要额外的开销)。</p></li><li><p>当引用计数为0时，该对象没有被使用，可以进行析构。</p></li><li><p>循环引用：引用计数会带来循环引用的问题。循环引用会导致堆里的内存无法正常回收，造成内存泄漏。</p></li></ol><p>weak_ptr:</p><ol><li>weak_ptr 被设计为与 shared_ptr 共同工作，用一种观察者模式工作。</li><li>作用是协助 shared_ptr 工作，可获得资源的观测权像旁观者那样观测资源的使用情况。<br> 观察者意味着weak_ptr只对 shared_ptr 进行引用，而不改变其引用计数，当被观察的 shared_ptr失效后，相应的 weak_ptr也相应失效。</li></ol>`,32);function v(_,b){const a=t("ExternalLinkIcon");return p(),o("div",null,[r,u,d,k,n("p",null,[s("先推荐一篇"),n("a",m,[s("Microsoft的官方文档"),c(a)]),s("，讲的非常好")]),h])}const q=e(i,[["render",v],["__file","RAII.html.vue"]]),f=JSON.parse('{"path":"/posts/RAII.html","title":"RAII和智能指针","lang":"en-US","frontmatter":{"category":["Cpp STL"],"tag":["Cpp"]},"headers":[{"level":2,"title":"对象生存期","slug":"对象生存期","link":"#对象生存期","children":[]},{"level":2,"title":"RAII","slug":"raii","link":"#raii","children":[]},{"level":2,"title":"智能指针","slug":"智能指针","link":"#智能指针","children":[{"level":3,"title":"unique_ptr","slug":"unique-ptr","link":"#unique-ptr","children":[]},{"level":3,"title":"shared_ptr和weak_ptr","slug":"shared-ptr和weak-ptr","link":"#shared-ptr和weak-ptr","children":[]}]}],"git":{"updatedTime":1713876062000,"contributors":[{"name":"Zari_Tsu","email":"zaritsu030907@gmail.com","commits":4}]},"filePathRelative":"posts/RAII.md","excerpt":"\\n<blockquote>\\n<p>引: c++不像Java或是Python拥有自动的回收处理机制</p>\\n</blockquote>\\n<p>这篇来讲讲cpp当中的智能指针，正如引子讲的那样，c或c类语言基本都没一种自动的回收机制，这也是出现什么野指针、空悬指针、重复释放、内存泄漏等等tricky bug的原因。</p>\\n<p>在c当中确确实实就只能通过很小心翼翼的设计才能避免这个问题，但是在c++当中引入的RAII可以一定程度的解决这个问题。</p>\\n<p>先推荐一篇<a href=\\"https://learn.microsoft.com/zh-cn/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Microsoft的官方文档</a>，讲的非常好</p>"}');export{q as comp,f as data};
